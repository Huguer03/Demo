---
title: "Péndulo Doble"
format:
  html:
    code-fold: true
jupyter: python3
---

# Definiciones

Lo primero que haremos serán las definiciones.

```{python}
import numpy as np
import sympy as smp
from scipy.integrate import odeint
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec

smp.init_printing(use_latex=True)

g, l1, l2, m1, m2, t, = smp.symbols('g l_1 l_2 m_1 m_2 t')

def argumentos():
  g  = 9.81
  l1 = 1
  m1 = 1
  l2 = 0.5
  m2 = 4
  return g, l1, l2, m1, m2

theta1, theta2 = smp.symbols(r'\theta_1 \theta_2', cls=smp.Function)
omega1, omega2 = smp.symbols(r'\dot{\theta_1} \dot{\theta_2}', cls=smp.Function)

theta1 = theta1(t)
theta2 = theta2(t)
omega1 = omega1(t)
omega2 = omega2(t)

theta1_d,  theta2_d  = smp.diff(theta1,   t), smp.diff(theta2,   t)
theta1_dd, theta2_dd = smp.diff(theta1_d, t), smp.diff(theta2_d, t)

```

Tenemos que poner las coordenadas de las articulaciones en función de $\theta_1$ y $\theta_2$:

```{python}
x1, x2, y1, y2 = smp.symbols('x_1 x_2 y_1 y_2', cls=smp.Function)
x1p, x2p, y1p, y2p = smp.symbols('x_1 x_2 y_1 y_2') #Auxiliares solo para poder hacer el print

x1 =  l1 * smp.sin(theta1)
y1 = -l1 * smp.cos(theta1)

x1_d = smp.diff(x1, t)
y1_d = smp.diff(y1, t)

x2 =  l1 * smp.sin(theta1) + l2 * smp.sin(theta2)
y2 = -l1 * smp.cos(theta1) - l2 * smp.cos(theta2)

x2_d = smp.diff(x2, t)
y2_d = smp.diff(y2, t)

display(smp.Eq(x1p, x1))
display(smp.Eq(y1p, y1))
display(smp.Eq(x2p, x2))
display(smp.Eq(y2p, y2))
```

# Lagrangiano

Vamos a definir el Lagrangiano para conseguir las ecuaciones de movimiento:


```{python}
Lagrangiano = smp.symbols('L')
T = 0.5 * (m1 * (x1_d**2 + y1_d**2) + m2 * (x2_d**2 + y2_d**2))
V = g * (m1 * y1 + m2 * y2)
L = T - V
display(smp.Eq(Lagrangiano,L.simplify().subs(theta1_d, omega1).subs(theta2_d, omega2)))
```

Para conseguir las ecuaciones de movimiento usaremos la ecuación de Euler Lagrange:

$$
\frac{d}{dt}\left(\frac{\partial L}{\partial \dot{\theta}}\right) - \frac{\partial L}{\partial \theta} = 0
$$

Con esto las ecuaciones de movimiento quedaran tal que:

```{python}
eq1, eq2 = smp.symbols(r'\ddot{\theta_1} \ddot{\theta_2}')

EulerLagrange1 = smp.diff(smp.diff(L, theta1_d), t).simplify() - smp.diff(L, theta1)
EulerLagrange2 = smp.diff(smp.diff(L, theta2_d), t).simplify() - smp.diff(L, theta2)

sol = smp.solve((EulerLagrange1, EulerLagrange2), (theta1_dd, theta2_dd))

display(smp.Eq(eq1, sol[theta1_dd].simplify().subs(theta1_d, omega1).subs(theta2_d, omega2)))
display(smp.Eq(eq2, sol[theta2_dd].simplify().subs(theta1_d, omega1).subs(theta2_d, omega2)))
```

# Simulación

Hasta ahora hemos estado resolviendo todo de manera simbólica, ahora el objetivo es resolver la ecuación diferencial de segundo grado de manera numérica.

```{python}
theta1_dd_f = smp.lambdify((g,l1,l2,m1,m2,theta1,omega1,theta2,omega2), sol[theta1_dd].subs(theta1_d, omega1).subs(theta2_d, omega2), 'numpy')
theta2_dd_f = smp.lambdify((g,l1,l2,m1,m2,theta1,omega1,theta2,omega2), sol[theta2_dd].subs(theta1_d, omega1).subs(theta2_d, omega2), 'numpy')

def f(u,t,g,l1,l2,m1,m2):
  theta1, theta2, omega1, omega2 = u
  return [omega1, omega2, theta1_dd_f(g,l1,l2,m1,m2,theta1,omega1,theta2,omega2), theta2_dd_f(g,l1,l2,m1,m2,theta1,omega1,theta2,omega2)]

t_vals = np.linspace(0,10,5000)

sol_num = odeint(f, [0, np.pi/2, 0, 0], t_vals, args=argumentos())

theta1_vals1 = sol_num[:,0]
theta2_vals1 = sol_num[:,1]
omega1_vals1 = sol_num[:,2]
omega2_vals1 = sol_num[:,3]

sol_num = odeint(f, [-np.pi/2, np.pi/4, -1, 1], t_vals, args=argumentos())

theta1_vals2 = sol_num[:,0]
theta2_vals2 = sol_num[:,1]
omega1_vals2 = sol_num[:,2]
omega2_vals2 = sol_num[:,3]
```

Como sabemos este sistema es caótico, por lo que encontraremos algunos resultados más predecibles que otros. Como por ejemplo:

```{python}
#| label: fig-1
#| fig-cap: "Caso regular"
plt.figure(figsize=(12, 6))
gs = gridspec.GridSpec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1])

ax1 = plt.subplot(gs[0, 0])
ax1.plot(t_vals, theta2_vals1)
ax1.set_xlabel('Tiempo (s)')
ax1.set_ylabel('Ángulo (rad)')
ax1.set_title('Posición Angular')

ax2 = plt.subplot(gs[1, 0])
ax2.plot(t_vals, omega2_vals1)
ax2.set_xlabel('Tiempo (s)')
ax2.set_ylabel('Velocidad (rad/s)')
ax2.set_title('Velocidad Angular')

ax3 = plt.subplot(gs[:, 1]) 
ax3.plot(theta2_vals1, omega2_vals1)
ax3.set_xlabel('Ángulo (rad)')
ax3.set_ylabel('Velocidad (rad/s)')
ax3.set_title('Diagrama de Fase')
ax3.grid(True)

plt.tight_layout()
plt.show()
```

Pero otros son completamente caóticos:

```{python}
#| label: fig-2
#| fig-cap: "Caso caótico"
plt.figure(figsize=(12, 6))
gs = gridspec.GridSpec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1])

ax1 = plt.subplot(gs[0, 0])
ax1.plot(t_vals, theta2_vals2)
ax1.set_xlabel('Tiempo (s)')
ax1.set_ylabel('Ángulo (rad)')
ax1.set_title('Posición Angular')

ax2 = plt.subplot(gs[1, 0])
ax2.plot(t_vals, omega2_vals2)
ax2.set_xlabel('Tiempo (s)')
ax2.set_ylabel('Velocidad (rad/s)')
ax2.set_title('Velocidad Angular')

ax3 = plt.subplot(gs[:, 1]) 
ax3.plot(theta2_vals2, omega2_vals2)
ax3.set_xlabel('Ángulo (rad)')
ax3.set_ylabel('Velocidad (rad/s)')
ax3.set_title('Diagrama de Fase')
ax3.grid(True)

plt.tight_layout()
plt.show()
```

Cosa que igual es obvia pero de la que nunca me había dado cuenta, en el diagrama de fases se observa muy bien como de caótico es un sistema. Ya que podemos observar que en @fig-1 el espacio de fases es mucho más regular que el de la @fig-2

## Trayectorias

Podemos tratar de conseguir la trayectoria en el plano XY de la ultima bola. Del primer caso quedaría tal que:


```{python}
x_f = smp.lambdify((l1, l2, theta1, theta2), x2, 'numpy')
y_f = smp.lambdify((l1, l2, theta1, theta2), y2, 'numpy')

x_vals = x_f(1, 0.5, theta1_vals1, theta2_vals1)
y_vals = y_f(1, 0.5, theta1_vals1, theta2_vals1)

plt.plot(x_vals, y_vals)
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.title('Trayectoria')
plt.grid(True)
plt.tight_layout()
plt.show()
```

Mientras que el del segundo caso quedaría tal que:


```{python}
x_vals = x_f(1, 0.5, theta1_vals2, theta2_vals2)
y_vals = y_f(1, 0.5, theta1_vals2, theta2_vals2)

plt.plot(x_vals, y_vals)
plt.xlabel('x (m)')
plt.ylabel('y (m)')
plt.title('Trayectoria')
plt.grid(True)
plt.tight_layout()
plt.show()
```